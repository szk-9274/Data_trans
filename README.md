### AM
##### ネットワーク通信
```
ア       アプリケーション層
プ       プレゼンテーション層
セ       セッション層
ト  ゲ   トランスポート層     ゲートウェイ  
ネ  ル   ネットワーク層       ルータ       IPアドレス
デ  ブ   データリンク層       ブリッジ     MACアドレス
物  リ   物理層              リピータ
```

##### RAID
```
0 ス         ストライピング
1 ミ         ミラーリング
2 ハミ       ハミング符号
3 バ         バイト単位＋パリティ1台
4 ブ         ブロック単位＋パリティ1台
5 分散       ブロック単位＋パリティ分散
6 2重分散    ブロック単位＋2重パリティ分散
```

##### バックアップ差分
- フルバックアップ
    すべてのファイルをバックアップ
    更新情報のリセットあり
- 差分バックアップ
    最初のフルバックアップ以降、1回目のバックアップからの差分を2回目、3回目・・
    と差分を残す
    更新情報はリセットしない（初回フル以降はずっとたまる）
- 増分バックアップ
    前回のバックアップ以降に更新されたファイルだけをバックアップ
    毎回バックアップ後に更新情報をリセット
    イメージは前回のコミットしか残していないgit

##### UML
UMLは、システムやソフトウェアの設計・構造・動きを、誰でも理解しやすい「図」で表すための標準的な方法

1. クラス図
用途: システムの「設計」や「構造」を明確にしたいとき
場面:プログラムの設計段階で、クラス（部品）やその関係（継承・関連・依存など）を整理したいとき
実装前に、クラス構成をチームで共有したいとき

2. ユースケース図
用途: 「誰が」「何をできるか」＝システムの利用シナリオを把握したいとき
場面:要件定義や初期設計の段階で、ユーザーや他システムがシステムとどう関わるかを整理したいとき
利用者視点でシステムの全体像や機能の範囲を説明したいとき

3. シーケンス図
用途: システム内の「やりとりの流れ（順序）」を詳しく知りたいとき
場面:ある処理がどのような順番で進むか、どのクラス／オブジェクト間でメッセージがやりとりされるかを説明したいとき
複雑な処理フローの詳細な挙動を確認・議論したいとき

4. アクティビティ図
用途: 「処理の流れ」や「分岐」「繰り返し」などを図式化したいとき
場面:業務フローやアルゴリズムなど、手順が分岐・ループを含む場合に全体の流れを整理したいとき
人やシステムが何をどう進めるか、流れで見たいとき

5. 状態遷移図
用途: 「モノやシステムの状態の変化」を明示したいとき
場面:あるオブジェクトやシステムが、どんな状態を持ち、どう変化するかを説明したいとき
例：ドア（開いている／閉じている）、ユーザー（未ログイン／ログイン中／ロック中）など、状態管理が必要な場面

##### SQL
| 演算名         | 英語               | 役割・説明                                         | SQLでの例           |  
|----------------|--------------------|----------------------------------------------------|---------------------|  
| 射影           | projection         | 特定の列（属性）だけを取り出す                     | SELECT 列名...      |  
| 選択           | selection          | 条件に合う行（レコード）だけを取り出す             | WHERE句             |  
| 結合           | join               | 複数の表を条件で結びつけて新しい表を作る           | JOIN句              |  
| 和             | union              | 2つの表を縦方向に合体し、重複を除いて全行を得る     | UNION               |  
| 差             | difference         | 1つの表にあってもう1つの表にない行を取り出す        | EXCEPT（DBによる）  |  
| 直積           | Cartesian product  | 2つの表の全組み合わせを作る                        | FROM A, B           |  

##### スタブとドライバ
- スタブ（Stub）
テスト対象モジュールが「呼び出す側」（下位のモジュール）が未完成なときに、代わりに使う「仮の部品」
```
A（テスト対象）→ B（未完成）→ C  
このとき、Bをスタブで代用  
```
- ドライバ（Driver）
テスト対象モジュールが「呼び出される側」（下位のモジュール）の場合に、その上位モジュールの代わりに使う「仮の部品」
```
A（未完成）→ B（テスト対象）  
このとき、Aの代わりにドライバでBを呼び出す  
```

##### テストケース
判定条件網羅は、条件が真・偽の両方を通るので、
必ずそれに含まれる命令（文）もすべて通る。
つまり判定条件網羅 ⊃ 命令網羅（判定条件網羅は命令網羅を必ず満たす）

##### 線形計画法
以下のような形式の問題の解法。  
  
|      | 製品X | 製品Y | ... | 資源の総量 |  
|------|-------|-------|-----|------------|  
| 資源A| a1    | a2    | ... | A_total    |  
| 資源B| b1    | b2    | ... | B_total    |  
| ...  | ...   | ...   | ... | ...        |  
  
- 製品の利益：    
  - 製品X：Px 円  
  - 製品Y：Py 円  
  
式を立てる  
- 資源Aの制約：    
  a1*X + a2*Y + ... <= A_total  
- 資源Bの制約：    
  b1*X + b2*Y + ... <= B_total  
- （その他の制約も同様に）  
- X >= 0, Y >= 0, ...  
  
目的（最大化したいもの）  
- 利益最大化：    
  利益 = Px*X + Py*Y + ...  
  
5. 境界点・交点の計算  
- 各制約式の**等号**で交点を求める（連立方程式を解く）  
- 代表的な点：  
  - X = 0, Y = 0  
  - 各制約の交点（例：a1*X + a2*Y = A_total と b1*X + b2*Y = B_total を連立）  
  - 制約の端点（X=0のときのY、Y=0のときのX など）  
 
  
■【例】計算フォーマット 
  
問題の表  
|      | 製品X | 製品Y | 資源の総量 |  
|------|-------|-------|------------|  
| 資源A| 2     | 1     | 100        |  
| 資源B| 1     | 2     | 80         |  
  
利益：製品X=100円、製品Y=150円  
   
  
制約式  
- 2X + 1Y <= 100  
- 1X + 2Y <= 80  
- X >= 0, Y >= 0  
  
関数  
- 利益 = 100X + 150Y  
  
境界点・交点の計算  
- X=0のとき：Y=100, Y=40 → Y=40（小さい方）  
- Y=0のとき：X=50, X=80 → X=50（小さい方）  
- 交点：2X + Y = 100, X + 2Y = 80 を連立して X=40, Y=20  
  
利益計算  
- (X=0, Y=40): 0*100 + 40*150 = 6,000  
- (X=50, Y=0): 50*100 + 0*150 = 5,000  
- (X=40, Y=20): 40*100 + 20*150 = 7,000  
  
最大値  
- 最大利益：7,000円（X=40, Y=20 のとき）
  
##### OSSの定義
- ソースコードが公開され、利用・改変・再配布が自由なソフトウェア
- 著作権が存在する

##### アクセス実行時間
- キャッシュメモリの場合の実行時間
  平均アクセス時間 ＝ ヒット率×キャッシュアクセス時間 ＋ ミス率×主記憶アクセス時間  

- ディスクの場合の実行時間
  平均アクセス時間 ＝ シークタイム ＋ 回転待ち時間 ＋ データ転送時間  

##### パリティビット
- データの誤り検出のために付ける補助ビット。
データ中の「1」の数が偶数になるように付けるのが「偶数パリティ」、奇数になるように付けるのが「奇数パリティ」。
- 垂直パリティとは
データの各行ごとにパリティビットを付加する方法。
各行の末尾にパリティビットを付けることで、各行（縦方向）の誤り検出ができる。
偶数／奇数パリティを1行ごとに付けて、データが複数行になったもの。
つまり「パリティビットを複数行に展開したもの」とイメージしてOK。

- 水平パリティとは
各列ごとにパリティビットを付加する方法。
複数行のデータがある場合、それぞれの列（横方向）でパリティビットを付けることで、各列の誤り検出ができる。

- 垂直・水平パリティの組み合わせ（2次元パリティ）
行と列の両方にパリティビットを付ける方法。
単一ビット誤りなら、どのビットが誤ったか特定・訂正できる。
2ビット誤りについては、検出できないことがある。

ポイントまとめ
垂直パリティも水平パリティも、「どこにパリティビットを付けるか」の違いだけで、
付ける値（0か1か）は、システムが偶数パリティか奇数パリティかで決まる。
どちらも1ビット誤りの検出には有効だが、2ビット同時誤りなど偶数個の誤りが起きると検出できないことがあるので注意。

##### 割り込み
- 外部割込み（External Interrupt）
主な例：
キーボードやマウスの操作
タイマー（クロック）信号
外部機器（プリンタ、ネットワークなど）からの信号
ハードウェア割込みとも呼ばれる。

- 内部割込み（Internal Interrupt）。
主な例：
0による除算など、命令実行中のエラー（例外、トラップ）
プログラムによる明示的な割り込み命令（ソフトウェア割込み）
オーバーフローやメモリアクセス違反
ソフトウェア割込みや**例外（Exception）**とも呼ばれる。



------
### PM
# UTF-8とは（超要点）

- Unicode（文字の番号：U+xxxx）を **1〜4バイト**に変換する方式  
- ASCII（U+0000〜007F）はそのまま1バイト  
- Web標準で世界中で最も使われるエンコード方式

---

# UTF-8 のバイト構造

| Unicode範囲 | UTF-8形式 | バイト数 |
|-------------|-----------|----------|
| U+0000–007F | `0xxxxxxx` | 1 |
| U+0080–07FF | `110xxxxx 10xxxxxx` | 2 |
| U+0800–FFFF | `1110xxxx 10xxxxxx 10xxxxxx` | 3 |
| U+10000–10FFFF | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` | 4 |

---

# UTF-8 変換手順（例：あ = U+3042）

## ① Unicode の符号位置を2進数にする
U+3042 → 11000001000010(2)
## ② 対応する UTF-8 フォーマットを選ぶ（U+0800〜FFFF → 3バイト）
1110xxxx 10xxxxxx 10xxxxxx
## ③ x に右詰めでビットを埋める
1110 1100
10 000100
10 000010
## ④ 8ビットごとに区切ってバイト列にする
11100011 10000001 10000010
## ⑤ 16進に変換
E3 81 82
→ これが「あ」の UTF-8。

# まとめ（最重要ポイント）

- コンピュータは文字を直接扱えない → **バイト列**が必要  
- Unicode は文字に番号（U+xxxx）を与える  
- UTF-8 はその番号を **1〜4バイト**に変換する  
- ASCII互換性が強く、全世界で標準化されている  

---

# 基本的な素数判定アルゴリズム（やり方まとめ）

## ✔ STEP 1：対象の数 n を決める
n が 2 未満なら素数ではない。

## ✔ STEP 2：2 〜 √n の整数までループする
ループ変数 j を

```
j = 2, 3, 4, ..., floor(√n)
```

まで 1 ずつ進める。

## ✔ STEP 3：割り切れるかチェックする
各 j について

```
if n % j == 0:
    → n は素数ではない（合成数）
```

と判定して処理を終える。

## ✔ STEP 4：1つも割り切れなければ素数
ループを通して一度も `n % j == 0` にならなければ

```
n は素数（prime number）
```

と判定する。

## ✔ ポイント
- 調べる範囲は **2〜√n まで**で十分  
- 最も基本的で汎用的な素数判定方法  
- 初学者向けアルゴリズムとして多くの教科書で採用される









