## キャリアデザインシート
省略
## ＜成果＞目標管理＆フィードバックシート
##### (1)組織目標
・量産化プロへの基盤づくり
・仕事の価値向上
・人,組織の成長
##### (1)私の役割
活動テーマ：SoC使いこなし/検査設計
対応内容：既存検査ソフト、評価ソフト等改善、流用
##### (2)前年度からの課題
1.ADU量産工程検査における各工程の最適化・検査不良の削減
##### (3)チャレンジ目標・個人目標
【検査ソフト自動化による業務効率化と標準化】 
1. 前年度課題である ADU量産工程検査における各工程の最適化・検査不良の削減 を目的として、検査ソフトインテグレーションの効率化を推進する。 
2. 検査ソフトインテグレーションを実施し、各工程の自動化範囲を拡大して業務効率を高める。 
3. 自動化フローや運用フローを手順書として標準化し、属人化を解消してチーム全体での活用を推進する。

##### (3)チャレンジ目標・本人申告/上司評価
##### 上期
検査ソフトインテグレーションおよびデバッグ工程の自動化を実現し、一部自動化ツールの開発・業務適用を実現した。今回の自動化ツールの導入は、チーム内でも前例がなく、仕様策定や運用フローの構築をゼロから行う必要があったため、既存手順との整合性確認など、手探りで課題を一つずつ解消しながら進めた。何度もテスト・改善を重ねた結果、一部工程での自動化に成功し、現時点で9回の正式リリースに自動化を適用し、従来10hかかっていた作業を6hに短縮（約40%工数削減）、累計36hの削減効果を達成している。さらに、ECUへの書き込みファイルの正確性を保証するため、ファイルごとに固有で不変なハッシュ値を活用し、書き込み前後のハッシュ値を自動で比較・検証できる仕組みをデバッグ工程に組み込んだ。これにより書き込みミスやファイル違いによる手戻りを防止し、出図時の検査ソフトの品質向上に貢献した。

##### 下期
下期においては、上期で実現した一部自動化をさらに発展させ、検査ソフトインテグレーションの完全自動化を達成した。具体的には、スクリプトを一つ実行するだけで作業者に依存せず誰でもインテグレーション作業を完結できる自動化スクリプトを作成し、先輩方の助言や実作業班からのフィードバックを取り入れながら改善を重ねて完成させた。この仕組みでは、インテグレーションに加えてデプロイ（成果物の配置）も自動化し、デバッグ環境や本番環境への展開を人手を介さず実行できるようにした。効果として、上期時点で10h→6hに短縮していた作業をさらに1.5日短縮し、年間では従来10hかかっていた作業を4.5hまで削減（削減率55%）することに成功した。また、自動デプロイにより書き込みミスや配置ミスといったヒューマンエラーを排除し、手戻り防止と品質向上を実現した。さらに、作業者のスキルに依存しない標準化を達成し、BCP（事業継続計画）業務においても同様の自動インテグスクリプトを活用して効率化を図り、マニュアル整備を通じて業務の標準化に貢献した。

##### (4)重点実施目標①・個人目標
【量産工程用検査Scriptの活用による品質改善と効率化】 
1. ADU先頭開発における工程不良調査を実施しながら、関係部署と連携して課題解決を進める。 
2. 本社環境で量産工程用検査Scriptの動作・デバッグを可能にし、工程不良の原因調査を迅速化する。

##### (4)重点実施目標①・本人申告/上司評価
##### 上期
ADU先頭開発において、工程不良調査を関係部署と連携しながら進め、詳細な調査を実施して製造部などの関係者と協力し、最適な技術提案を行った。その中で、量産工程用検査Scriptの本社環境適用を自動化するツールを作成し、本社環境検査設備にて量産工程用検査Scriptを動作・デバッグ可能にした。従来は全体で180分の作業時間を要していた作業を、自動化後は全ファイルの置換およびチェック作業を約30分で完了できるようになり、作業時間を約83%削減することに成功した。これにより、業務効率が改善し、工程不良原因調査の迅速化や品質改善に貢献した。

##### 下期
上期で作成した量産工程用検査Script変換ツールによる工数削減効果をさらに発展させ、下期では本社環境のFalcon自動検査ベンチを活用した緊急対応を実施した。具体的には、工程投入前の緊急デバッグ要求に対して、本社環境用の新規検査スクリプトを迅速に作成・適用し、詳細な検証を実施した。その結果、問題なしと判断できるデータを取得し、ソフトを予定通り量産工程へリリースすることができた。本社環境でのデバッグ体制を確立し、工程不良の未然防止と品質保証に貢献した。

##### (5)重点実施目標②・個人目標
【製品ソフト書き込み・納入プロセスの確立と課題解決】 
1. 製品統括と連携し、BEV 基板の製品ソフト書き込みおよび納入業務を支援する。環境準備・構築を整備し、全体プロセスを提示して体制を構築する。 
2. 問題発生時は関係部署や専門家を巻き込み、解決策を迅速に実行。改善ポイントをフィードバックし、属人化を防ぎ効率化・品質向上を図る。

##### (5)重点実施目標②・本人申告/上司評価
##### 上期
製品統括と密に連携し、BEV基板の製品ソフト書き込みおよび納入業務の支援に従事。事前に環境を整備し、全体のプロセスや運用フローを明確にすることで、最適な判断のもと円滑に作業を推進した。作業中に生じた課題については、関係者や専門家と連携しながら迅速な対応を図り、滞りのない業務遂行を実現。さらに、運用手順のマニュアル化と現場からのヒアリングを通じて標準化を進め、誰もが同じ基準で作業できる体制を構築した。これら一連の取り組みにより、チーム全体の業務効率化と品質向上に貢献した。

##### 下期
上期で培ったBEV基板の製品ソフト書き込みに関する知見を活かし、下期は回路評価グループへのノウハウ移管と業務支援に注力した。ソフトウェアの知見が少ない回路評価グループからの質問や相談に対して密に連携しながら対応し、製品ソフト書き込みの手順や注意点をレクチャーした。その結果、回路評価グループの後輩メンバーが自立して製品ソフトの書き込み作業を遂行できる体制を構築し、業務の円滑な推進と技術の標準化に貢献した。

##### (6)重点実施目標③・個人目標
【電源回路評価を通じた技術力習得と改善提案】 
1. BEV電源回路評価業務を通じて、自動評価環境の短期構築・評価実施スキルを習得する。 
2. 各評価項目の目的・観点を理解し、発生した課題やNG要因について主体的に考察する。 
3. 得られた知見を整理し、指導者へ改善提案を行うことで、評価方法の改善と効率化に貢献する。

##### (6)重点実施目標③・本人申告/上司評価
##### 上期
BEVの電源回路評価業務を通じて、短期間で自動評価環境の構築・評価スキルを習得し、評価方法や観点を理解して主体的に取り組んだ。評価中にはPMICで「不要出力が停止しない」問題に直面したが、データシートからアドレス変更を特定し改善提案を実施。さらに前製品担当者と連携し、I2C通信で個別出力停止を可能にする手法を確立した。これらの取り組みにより、知見を提案しながら技術力を高め、評価方法の改善と効率化に貢献した。

##### 下期
上期でBEV電源回路評価を通じて習得した自動評価環境の構築スキルを、下期ではADU製品の不具合調査業務に展開し、効果を発揮した。ADU製品で多数の不具合が顕在化した際、上期で培ったノウハウを活かして迅速に評価環境を構築し、先輩が使いやすいUIの整備やリモート操作の実現、連続試験の自動化（安定化電源の自動制御、Ethernet経由のTelnet接続自動化など）を実施した。これにより不具合調査業務の効率化に大きく貢献した。環境構築においては、上期で関係者と密に連携しながらQ&Aを重ねて構築スキルを身に付けた経験が活かされ、下期では他部署とも協力しながら短期間で評価環境を立ち上げることができた。上期で習得した技術力を実務に適用し、組織横断的な課題解決を推進できた。

##### (7)人材育成目標・個人目標
【継続学習による資格取得とスキル向上】 
1. 週4時間以上の学習を継続し、デンソー検定（電子製品系）に合格する。 
2. TOEICスコアを維持・向上させ、語学力を業務に活用できる状態を保つ。 
3. 基本情報技術者試験に合格し、IT基盤知識の強化と業務応用力を高める。

##### (7)人材育成目標・本人申告/上司評価
##### 上期
週4時間以上の学習が継続できており、デンソー検定受験済み。(結果通知は12月) 
基本情報技術者試験の学習についても継続できており、10月に受験予定。
TOEICは2月受験予定。

##### 下期
週4時間以上の継続学習を実施し、デンソー検定（電子製品系）に合格することができた。基本情報技術者試験については、2025年11月に合格を達成し、IT基盤に対する知識が強化され、業務への応用力が高まった。継続的な自己研鑽を通じて、技術者としての基礎力向上を実現できた。

##### (8)その他成果・本人申告/上司評価
##### 上期
 1. Pythonハンズオン教育 受講・修了 　
 Pythonの実践的なスキルを習得し、チャレンジ目標である検査ソフトインテグレーション作業の一部自動化を実現。 
 2. 生成AIワーキンググループ（AIWG） 実施・中間報告 
 「AIとは何か」から、その活用方法・ノウハウまで知見を幅広く習得。 
 3. YY活動 リーダーとして実施・中間報告 　
 メンバーのES向上を目的に、月1回の活動を企画・主催。メンバーを取りまとめ、チームの活性化と組織力向上に貢献。 
 4. DX活動 リーダーとして実施・中間報告 　
 社内DX推進チームのリーダーとして、メンバー取りまとめ・DX活動内容の業務適用を実施。活動内容は業務に適用され、下期にはさらなる効率化を狙う。 
 5. 実車体験会運営への参画 　
 ES向上・システム設計力向上の効果確認を目的にアンケートを作成。班決めやルート選定、運営全般を担当し、イベントの円滑な進行と参加者満足度向上に貢献。

まとめ：これら5つの活動を通じて、新しい取り組みを推進するリーダーシップを経験することができた。結果として、業務効率化や品質向上に加えて、組織力の強化と自身の成長につながった。

##### 下期
 1. Pythonハンズオン教育 受講・修了済み

 2. 生成AIワーキンググループ（AIWG） 最終報告まで完了  
 AIの基本的な使い方やノウハウを習得し、業務への応用ができている。

 3. YY活動 リーダーとして実施・最終報告まで完了  
 メンバーのES向上を目的に月1回の活動を継続し、メンバーを取りまとめて組織力向上に貢献した。

 4. DX活動 リーダーとして実施・最終報告まで完了  
 業務効率化を推進し、DX報告会での報告も完了している。

##### (9)次年度に残された課題


## ＜発揮能力＞目標管理＆フィードバックシート

##### (1)前期（前年度）からの課題
1.ADU量産工程検査における各工程の最適化・検査不良の削減
##### (2)意識　重点項目の選択
【使命感を持って動く】
社会貢献のために、自らの果たすべき役割を認識し、常に当事者として苦労を厭わず、強い意思と信念をもって自らの責任を全うする姿勢
【自らを高める】
目指す姿を描き、その実現に向けて、技量・教養・人格等の視点から高い目標を掲げ、自ら学ぶ努力を惜しまず、前向きに粘り強く挑戦し続ける姿勢
【顧客・周りを尊重する】
顧客・周りの関係者に対し誠実に接し、相手の意見に真摯に耳を傾けながら、要望や心情を把握した上で、相手に喜ばれる付加価値を提供する姿勢

##### (2)意識　重点項目の進展に向けた具体的な行動
(2)能力の伸展に繋がる具体的な場面（意識）
ADU量産工程検査における各工程の最適化・工程不良の調査実施時
(2)能力の伸展に繋がる具体的な行動（意識）
課題発生時は問題の切り分けから初め、ソフト要因ハード要因のどちらであるかを特定する。加えて、本社環境・実際の工程の環境差分を考慮しつつ、顧客に状況に応じた提案を行う。
##### (2)意識　振り返りとフィードバック

##### (3)技量-仕事　重点項目の選択
【考え抜く】
担当業務において、通常発生する問題について、前後工程も含めた視点から問題点を整理した上で、自身の業務の優先順位をつけ、対策を立案、実施する。
【判断する】
収集した情報を層別し、物事の結論と理由・原因を押さえた上で、上司、先輩に報告し、適切な対応を選ぶ。
【実行する】
計画に沿って、達成に向けた見通しをもちながら業務を進める。また、自身の業務の結果を振り返り改善する。

##### (3)技量-仕事　重点項目の進展に向けた具体的な行動
(3)能力の伸展に繋がる具体的な場面（技量-仕事）
検査設計Gとして、経験がない回路評価業務を実施し、評価Gと協力して業務に取り組んでいく場面
(3)能力の伸展に繋がる具体的な行動（技量-仕事）
検査G・回路Gの各々の知見を活かしながら業務を効率的に遂行する。その中で旧製品の同様の回路の評価結果を応用することで評価工数を削減を狙う。
##### (3)技量-仕事　振り返りとフィードバック

##### (4)技量-組織・人　重点項目の選択
【統率する】
自らの仕事ぶりを通じて周りの雰囲気を盛り上げながら、業務を遂行する。
【指導育成する】

【連携する】
相手の理解度を確認し、自分の考えを伝えて、物事が円滑に進むように、関係者と担当業務の調整を行う。

##### (4)技量-組織・人　重点項目の進展に向けた具体的な行動
(4)能力の伸展に繋がる具体的な場面（技量-組織・人）
電源回路評価において、評価NGがあり考察や調査が必要になる場面
(4)能力の伸展に繋がる具体的な行動（技量-組織・人）
評価NGの原因解析に必要な情報を自ら選定し、取得・分析する。またその考察を関係者と知見を共有することで技術提案につなげ、円滑に問題解決を促進する。
##### (4)技量-組織・人　振り返りとフィードバック

##### (5)その他申告





### AM
##### ネットワーク通信
```
ア       アプリケーション層
プ       プレゼンテーション層
セ       セッション層
ト  ゲ   トランスポート層     ゲートウェイ  
ネ  ル   ネットワーク層       ルータ       IPアドレス
デ  ブ   データリンク層       ブリッジ     MACアドレス
物  リ   物理層              リピータ
```

##### RAID
```
0 ス         ストライピング
1 ミ         ミラーリング
2 ハミ       ハミング符号
3 バ         バイト単位＋パリティ1台
4 ブ         ブロック単位＋パリティ1台
5 分散       ブロック単位＋パリティ分散
6 2重分散    ブロック単位＋2重パリティ分散
```

##### バックアップ差分
- フルバックアップ
    すべてのファイルをバックアップ
    更新情報のリセットあり
- 差分バックアップ
    最初のフルバックアップ以降、1回目のバックアップからの差分を2回目、3回目・・
    と差分を残す
    更新情報はリセットしない（初回フル以降はずっとたまる）
- 増分バックアップ
    前回のバックアップ以降に更新されたファイルだけをバックアップ
    毎回バックアップ後に更新情報をリセット
    イメージは前回のコミットしか残していないgit

##### UML
UMLは、システムやソフトウェアの設計・構造・動きを、誰でも理解しやすい「図」で表すための標準的な方法

1. クラス図
用途: システムの「設計」や「構造」を明確にしたいとき
場面:プログラムの設計段階で、クラス（部品）やその関係（継承・関連・依存など）を整理したいとき
実装前に、クラス構成をチームで共有したいとき

2. ユースケース図
用途: 「誰が」「何をできるか」＝システムの利用シナリオを把握したいとき
場面:要件定義や初期設計の段階で、ユーザーや他システムがシステムとどう関わるかを整理したいとき
利用者視点でシステムの全体像や機能の範囲を説明したいとき

3. シーケンス図
用途: システム内の「やりとりの流れ（順序）」を詳しく知りたいとき
場面:ある処理がどのような順番で進むか、どのクラス／オブジェクト間でメッセージがやりとりされるかを説明したいとき
複雑な処理フローの詳細な挙動を確認・議論したいとき

4. アクティビティ図
用途: 「処理の流れ」や「分岐」「繰り返し」などを図式化したいとき
場面:業務フローやアルゴリズムなど、手順が分岐・ループを含む場合に全体の流れを整理したいとき
人やシステムが何をどう進めるか、流れで見たいとき

5. 状態遷移図
用途: 「モノやシステムの状態の変化」を明示したいとき
場面:あるオブジェクトやシステムが、どんな状態を持ち、どう変化するかを説明したいとき
例：ドア（開いている／閉じている）、ユーザー（未ログイン／ログイン中／ロック中）など、状態管理が必要な場面

##### SQL
| 演算名         | 英語               | 役割・説明                                         | SQLでの例           |  
|----------------|--------------------|----------------------------------------------------|---------------------|  
| 射影           | projection         | 特定の列（属性）だけを取り出す                     | SELECT 列名...      |  
| 選択           | selection          | 条件に合う行（レコード）だけを取り出す             | WHERE句             |  
| 結合           | join               | 複数の表を条件で結びつけて新しい表を作る           | JOIN句              |  
| 和             | union              | 2つの表を縦方向に合体し、重複を除いて全行を得る     | UNION               |  
| 差             | difference         | 1つの表にあってもう1つの表にない行を取り出す        | EXCEPT（DBによる）  |  
| 直積           | Cartesian product  | 2つの表の全組み合わせを作る                        | FROM A, B           |  


- SELECT
列選択ができる。*で全選択。
SELECT * FROM Artist;
列1,2を決定するとその順番で表が作成される。
SELECT name, salary FROM emp;  
WHEREで条件付与もできる。
SELECT * FROM emp WHERE salary > 300000;  

- INSERT
テーブルにデータを追加する。
INSERT INTO emp (id, name, salary) VALUES (1, '山田太郎', 350000);  

- UPDATE 
WHEREなどを組み合わせて特定の項目を更新する。以下だとid1のsalaryを400000に設定。
UPDATE emp SET salary = 400000 WHERE id = 1;  

- DELETE
データ削除ができる。
DELETE FROM emp WHERE id = 1;  

- ORDER BY
テーブルを全選択し降順に並べている。昇順はASC
SELECT * FROM emp ORDER BY salary DESC;  

- GROUP BY
例：各部署ごとの平均給与を求める
SELECT dept, AVG(salary) FROM emp GROUP BY dept;  

##### スタブとドライバ
- スタブ（Stub）
テスト対象モジュールが「呼び出す側」（下位のモジュール）が未完成なときに、代わりに使う「仮の部品」
```
A（テスト対象）→ B（未完成）→ C  
このとき、Bをスタブで代用  
```
- ドライバ（Driver）
テスト対象モジュールが「呼び出される側」（下位のモジュール）の場合に、その上位モジュールの代わりに使う「仮の部品」
```
A（未完成）→ B（テスト対象）  
このとき、Aの代わりにドライバでBを呼び出す  
```

##### テストケース
判定条件網羅は、条件が真・偽の両方を通るので、
必ずそれに含まれる命令（文）もすべて通る。
つまり判定条件網羅 ⊃ 命令網羅（判定条件網羅は命令網羅を必ず満たす）

##### 線形計画法
以下のような形式の問題の解法。  
  
|      | 製品X | 製品Y | ... | 資源の総量 |  
|------|-------|-------|-----|------------|  
| 資源A| a1    | a2    | ... | A_total    |  
| 資源B| b1    | b2    | ... | B_total    |  
| ...  | ...   | ...   | ... | ...        |  
  
- 製品の利益：    
  - 製品X：Px 円  
  - 製品Y：Py 円  
  
式を立てる  
- 資源Aの制約：    
  a1*X + a2*Y + ... <= A_total  
- 資源Bの制約：    
  b1*X + b2*Y + ... <= B_total  
- （その他の制約も同様に）  
- X >= 0, Y >= 0, ...  
  
目的（最大化したいもの）  
- 利益最大化：    
  利益 = Px*X + Py*Y + ...  
  
5. 境界点・交点の計算  
- 各制約式の**等号**で交点を求める（連立方程式を解く）  
- 代表的な点：  
  - X = 0, Y = 0  
  - 各制約の交点（例：a1*X + a2*Y = A_total と b1*X + b2*Y = B_total を連立）  
  - 制約の端点（X=0のときのY、Y=0のときのX など）  
 
  
■【例】計算フォーマット 
  
問題の表  
|      | 製品X | 製品Y | 資源の総量 |  
|------|-------|-------|------------|  
| 資源A| 2     | 1     | 100        |  
| 資源B| 1     | 2     | 80         |  
  
利益：製品X=100円、製品Y=150円  
   
  
制約式  
- 2X + 1Y <= 100  
- 1X + 2Y <= 80  
- X >= 0, Y >= 0  
  
関数  
- 利益 = 100X + 150Y  
  
境界点・交点の計算  
- X=0のとき：Y=100, Y=40 → Y=40（小さい方）  
- Y=0のとき：X=50, X=80 → X=50（小さい方）  
- 交点：2X + Y = 100, X + 2Y = 80 を連立して X=40, Y=20  
  
利益計算  
- (X=0, Y=40): 0*100 + 40*150 = 6,000  
- (X=50, Y=0): 50*100 + 0*150 = 5,000  
- (X=40, Y=20): 40*100 + 20*150 = 7,000  
  
最大値  
- 最大利益：7,000円（X=40, Y=20 のとき）
  
##### OSSの定義
- ソースコードが公開され、利用・改変・再配布が自由なソフトウェア
- 著作権が存在する

##### アクセス実行時間
- キャッシュメモリの場合の実行時間
  平均アクセス時間 ＝ ヒット率×キャッシュアクセス時間 ＋ ミス率×主記憶アクセス時間  

- ディスクの場合の実行時間
  平均アクセス時間 ＝ シークタイム ＋ 回転待ち時間 ＋ データ転送時間  

##### パリティビット
- データの誤り検出のために付ける補助ビット。
データ中の「1」の数が偶数になるように付けるのが「偶数パリティ」、奇数になるように付けるのが「奇数パリティ」。
- 垂直パリティとは
データの各行ごとにパリティビットを付加する方法。
各行の末尾にパリティビットを付けることで、各行（縦方向）の誤り検出ができる。
偶数／奇数パリティを1行ごとに付けて、データが複数行になったもの。
つまり「パリティビットを複数行に展開したもの」とイメージしてOK。

- 水平パリティとは
各列ごとにパリティビットを付加する方法。
複数行のデータがある場合、それぞれの列（横方向）でパリティビットを付けることで、各列の誤り検出ができる。

- 垂直・水平パリティの組み合わせ（2次元パリティ）
行と列の両方にパリティビットを付ける方法。
単一ビット誤りなら、どのビットが誤ったか特定・訂正できる。
2ビット誤りについては、検出できないことがある。

ポイントまとめ
垂直パリティも水平パリティも、「どこにパリティビットを付けるか」の違いだけで、
付ける値（0か1か）は、システムが偶数パリティか奇数パリティかで決まる。
どちらも1ビット誤りの検出には有効だが、2ビット同時誤りなど偶数個の誤りが起きると検出できないことがあるので注意。

##### 割り込み
- 外部割込み（External Interrupt）
主な例：
キーボードやマウスの操作
タイマー（クロック）信号
外部機器（プリンタ、ネットワークなど）からの信号
ハードウェア割込みとも呼ばれる。

- 内部割込み（Internal Interrupt）。
主な例：
0による除算など、命令実行中のエラー（例外、トラップ）
プログラムによる明示的な割り込み命令（ソフトウェア割込み）
オーバーフローやメモリアクセス違反
ソフトウェア割込みや**例外（Exception）**とも呼ばれる。

##### 🚀 16進小数 → 10進変換 テンプレ
**0.X(16) = (X の10進値) ÷ 16**
例：
- C(16)=12 → 12÷16=0.75
- A(16)=10 → 10÷16=0.625

2桁なら：
0.XY16 = X×16^-1 + Y×16^-2

覚えるべきは「1桁なら /16 だけ」


##### 🚀 MTBF / MTTR → 稼働率テンプレ
稼働率：
A = MTBF / (MTBF + MTTR)

改善後：
- MTBF は増加（%分だけ足す）
- MTTR は減少（%分だけ引く）

例：
MTBF=3000 → +20% → 3600  
MTTR=1000 → -10% → 900  
A = 3600/(3600+900)=0.8=80%


##### 🚀 キャッシュヒット率テンプレ
実効アクセス時間 E：
E = (キャッシュ×H) + (主記憶×(1-H))

ヒット率 H を求めるとき：
**性能が同じ2構成 → E1 = E2 で方程式を作って解くだけ**


##### 🚀 ハッシュ衝突テンプレ（ASCII不要版）
ASCII を暗記する必要なし！

**アルファベットの位置差が10の倍数 → 衝突**

手順：
1. a=1, b=2, … と番号付け  
2. 差を計算  
3. 差 % 10 == 0 → 同じ 1 の位 → 衝突

例：d=4, x=24 → 差20 → 衝突


##### 🚀 ファイルアクセス・ハッシュ表インデックス テンプレ
基本：
h(key) = key % table_size

ASCII 十進値の1の位を使うなら：
h = ASCII(key) % 10  
（ASCIIそのものは不要。位置差テンプレで十分）

------
### PM
##### UTF-8とは（超要点）

- Unicode（文字の番号：U+xxxx）を **1〜4バイト**に変換する方式  
- ASCII（U+0000〜007F）はそのまま1バイト  
- Web標準で世界中で最も使われるエンコード方式

---

##### UTF-8 のバイト構造

| Unicode範囲 | UTF-8形式 | バイト数 |
|-------------|-----------|----------|
| U+0000–007F | `0xxxxxxx` | 1 |
| U+0080–07FF | `110xxxxx 10xxxxxx` | 2 |
| U+0800–FFFF | `1110xxxx 10xxxxxx 10xxxxxx` | 3 |
| U+10000–10FFFF | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` | 4 |

---

##### UTF-8 変換手順（例：あ = U+3042）

###### ① Unicode の符号位置を2進数にする
U+3042 → 11000001000010(2)
###### ② 対応する UTF-8 フォーマットを選ぶ（U+0800〜FFFF → 3バイト）
1110xxxx 10xxxxxx 10xxxxxx
###### ③ x に右詰めでビットを埋める
1110 1100
10 000100
10 000010
###### ④ 8ビットごとに区切ってバイト列にする
11100011 10000001 10000010
###### ⑤ 16進に変換
E3 81 82
→ これが「あ」の UTF-8。

##### まとめ（最重要ポイント）

- コンピュータは文字を直接扱えない → **バイト列**が必要  
- Unicode は文字に番号（U+xxxx）を与える  
- UTF-8 はその番号を **1〜4バイト**に変換する  
- ASCII互換性が強く、全世界で標準化されている  

---

##### 基本的な素数判定アルゴリズム（やり方まとめ）

###### ✔ STEP 1：対象の数 n を決める
n が 2 未満なら素数ではない。

###### ✔ STEP 2：2 〜 √n の整数までループする
ループ変数 j を

```
j = 2, 3, 4, ..., floor(√n)
```

まで 1 ずつ進める。

###### ✔ STEP 3：割り切れるかチェックする
各 j について

```
if n % j == 0:
    → n は素数ではない（合成数）
```

と判定して処理を終える。

###### ✔ STEP 4：1つも割り切れなければ素数
ループを通して一度も `n % j == 0` にならなければ

```
n は素数（prime number）
```

と判定する。

###### ✔ ポイント
- 調べる範囲は **2〜√n まで**で十分  
- 最も基本的で汎用的な素数判定方法  
- 初学者向けアルゴリズムとして多くの教科書で採用される

##### ⭐ 二進数 → 十進数変換アルゴリズム「穴埋め問題」解法テンプレート

基本情報で頻出の「二進 → 十進変換アルゴリズム穴埋め問題」を  
確実に解くためのテンプレート。

###### 🔍 1. まず“目的”を確認する

> 「2進数の文字列（例：'10010'）を10進整数に変換する」

この時点で思い出すべき公式は 1 つだけ：

**result = result × 2 + bit**

これは基数変換の共通公式  
（result = result × 基数 + 桁の値）の 2進バージョン。

###### 🔍 2. ループの方向を確認する（左→右か、右→左か）

- `for i = 1 to length` で  
  `binary[i]` を参照 → 左から読む（上位 → 下位）

- `binary[length - i + 1]` を参照 → 右から読む（下位 → 上位）

左から読むなら基本式そのまま：

```
result = result × 2 + int(binary[i])
```

###### ✂ 3. ×2 がない選択肢は即除外

以下の形は絶対ダメ：

- `result + int(...)`
- `result + ...`

理由：**数字の“位置（桁の重み）”を反映できない** → ただの 1 の個数カウントになる。


###### 🧮 4. 候補が残ったら簡単チェック（軽い検算）

テストケース `"10010"` → 18 を使う。

候補を 1〜2行だけ追って、方向がおかしければ即除外。

細かい表を書く必要はない。

###### 🎯 5. 最後に残るのは必ずこの形になる

```
result = result × 2 + int(binary[i])
```

もしくは、右から読む仕様なら：

```
result = result × 2 + int(binary[length - i + 1])
```

##### ✅ チェックリスト

- [ ] 目的は「2進→10進」？
- [ ] result = result × 2 + bit の形になってる？
- [ ] 添字（i / length-i+1）がループ方向と一致してる？
- [ ] ×2 がない選択肢は即切った？
